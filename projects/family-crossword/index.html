<!DOCTYPE html>
<html>
<head>
  <title>Crossword Generator</title>
  <style>
    body { font-family: Arial; padding: 20px; }
    canvas { border: 1px solid #000; }
    #gridCanvas { margin-top: 10px; }
  </style>
</head>
<body>

  <h2>Crossword Generator for Names</h2>
  <input type="text" id="nameInput" placeholder="Enter comma-separated names">
  <button onclick="generateCrosswords()">Generate</button>
  <button onclick="showNext()">Regenerate</button>
  <canvas id="gridCanvas" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 30;
    let allGrids = [];
    let currentGridIndex = 0;

    function generateCrosswords() {
      const names = document.getElementById('nameInput').value
        .split(',')
        .map(n => n.trim().toUpperCase())
        .filter(n => n.length > 0);

      if (names.length < 2) {
        alert('Please enter at least 2 names');
        return;
      }

      allGrids = [];
      currentGridIndex = 0;
      backtrack([], [], names);
      if (allGrids.length > 0) {
        drawGrid(allGrids[0]);
      } else {
        alert("No layout found");
      }
    }

    function showNext() {
      if (allGrids.length === 0) return;
      currentGridIndex = (currentGridIndex + 1) % allGrids.length;
      drawGrid(allGrids[currentGridIndex]);
    }

    function drawGrid(gridData) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const offset = 15; // offset for padding

      for (let item of gridData) {
        const { word, x, y, dir } = item;
        for (let i = 0; i < word.length; i++) {
          const cx = dir === 'H' ? x + i : x;
          const cy = dir === 'V' ? y + i : y;
          ctx.strokeRect(cx * cellSize + offset, cy * cellSize + offset, cellSize, cellSize);
          ctx.fillText(word[i], cx * cellSize + offset + 8, cy * cellSize + offset + 20);
        }
      }
    }

    function placeWord(existing, word) {
      const placements = [];

      if (existing.length === 0) {
        // First word
        placements.push([{ word, x: 10, y: 10, dir: 'H' }]);
        placements.push([{ word, x: 10, y: 10, dir: 'V' }]);
        return placements;
      }

      for (let placed of existing) {
        for (let i = 0; i < placed.word.length; i++) {
          for (let j = 0; j < word.length; j++) {
            if (placed.word[i] !== word[j]) continue;

            // Try perpendicular direction
            if (placed.dir === 'H') {
              const x = placed.x + i;
              const y = placed.y - j;
              if (canPlace(existing, word, x, y, 'V'))
                placements.push([...existing, { word, x, y, dir: 'V' }]);
            } else {
              const x = placed.x - j;
              const y = placed.y + i;
              if (canPlace(existing, word, x, y, 'H'))
                placements.push([...existing, { word, x, y, dir: 'H' }]);
            }
          }
        }
      }
      return placements;
    }

    function canPlace(existing, word, x, y, dir) {
      for (let i = 0; i < word.length; i++) {
        const cx = dir === 'H' ? x + i : x;
        const cy = dir === 'V' ? y + i : y;

        for (let e of existing) {
          for (let j = 0; j < e.word.length; j++) {
            const ex = e.dir === 'H' ? e.x + j : e.x;
            const ey = e.dir === 'V' ? e.y + j : e.y;

            if (cx === ex && cy === ey) {
              if (word[i] !== e.word[j]) return false; // conflict
            }
          }
        }
      }
      return true;
    }

    function backtrack(path, used, words) {
      if (used.length === words.length) {
        allGrids.push([...path]);
        return;
      }

      const remaining = words.filter(w => !used.includes(w));
      for (let word of remaining) {
        const placements = placeWord(path, word);
        for (let p of placements) {
          backtrack(p, [...used, word], words);
        }
      }
    }
  </script>

</body>
</html>
